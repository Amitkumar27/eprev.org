#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const config = require('../config');

function removedir(dirname) {
  fs.readdirSync(dirname, { encoding: 'utf8' }).forEach(filename => {
    const pathname = path.join(dirname, filename);
    const stats = fs.statSync(pathname);
    if (stats.isDirectory()) {
      removedir(pathname);
      fs.rmdirSync(pathname);
    } else {
      fs.unlinkSync(pathname);
    }
  });
}

function copy(src, dest) {
  createdir(path.dirname(dest));
  fs.copyFileSync(src, dest);
}

function write(dest, content) {
  createdir(path.dirname(dest));
  fs.writeFileSync(dest, content, { encoding: 'utf8' });
}

function createdir(dirname) {
  dirname.split(path.sep).reduce((rel, dirname) => {
    const pathname = path.join(rel, dirname);
    if (!fs.existsSync(pathname)) {
      fs.mkdirSync(pathname);
    }
    return pathname;
  }, '/');
}

const { Model } = require('../lib/model');
const { render } = require('../lib/template');

function build() {
  const model = new Model();

  console.log('Building...');

  if (fs.existsSync(config.dest)) {
    removedir(config.dest);
  }

  config.site.collections = model.collections;

  function generate(destination, template, page) {
    const context = {
      env: config.env,
      site: config.site,
      page,
    };
    const content = render(template, context);
    write(path.join(config.dest, destination), content);
  }

  function processHook(name) {
    const dirname = path.join(__dirname, '..', 'hooks', name);
    if (fs.existsSync(dirname)) {
      fs.readdirSync(dirname, { encoding: 'utf8' }).forEach(filename => {
        const pathname = path.join(dirname, filename);
        require(pathname)({ generate, model, config });
      });
    }
  }

  processHook('init');

  Object.keys(model.documents).forEach(pathname => {
    const doc = model.documents[pathname];
    const destination = doc.pathname.endsWith('/')
      ? doc.pathname + 'index.html'
      : doc.pathname;
    if (doc.layout) {
      generate(destination, doc.layout, doc);
    } else {
      copy(
        path.join(config.src, pathname),
        path.join(config.dest, destination),
      );
    }
  });

  processHook('copy');
  console.log('Done');
}

const watching = (process.argv.length === 3 && process.argv[2] === '--watch');
if (watching) {
  console.log('Watching...');
}

build();

if (watching) {
  let to;
  fs.watch(config.src, { recursive: true }, (eventType, filename) => {
    clearTimeout(to);
    to = setTimeout(build, 50);
  });
  fs.watch(path.join(__dirname, '..', 'templates'), { recursive: true }, (eventType, filename) => {
    clearTimeout(to);
    to = setTimeout(build, 50);
  });
}
