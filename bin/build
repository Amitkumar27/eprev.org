#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const config = require('../config');

function copy(src, dest) {
  createdir(path.dirname(dest));
  fs.copyFileSync(src, dest);
}

function write(dest, content) {
  createdir(path.dirname(dest));
  fs.writeFileSync(dest, content, { encoding: 'utf8' });
}

function createdir(dirname) {
  dirname.split(path.sep).reduce((rel, dirname) => {
    const pathname = path.join(rel, dirname);
    if (!fs.existsSync(pathname)) {
      fs.mkdirSync(pathname);
    }
    return pathname;
  }, '/');
}

const { Model } = require('../lib/model');
const { render, renderString } = require('../lib/template');
const colorize = require('../lib/colorize');

function build() {
  const model = new Model();

  process.stdout.write('Building... ');

  config.site.time = new Date();

  config.site.collections = model.collections;

  function generate(destination, template, page) {
    if (page && page.source) {
      page.content = renderString(page.source, {
        __name__: page.__name__,
        env: config.env,
        site: config.site,
      });
    }
    let content;
    if (template) {
      const context = {
        env: config.env,
        site: config.site,
        page,
      };
      content = render(template, context);
    } else {
      content = page.content;
    }
    write(path.join(config.dest, destination), content);
  }

  function processPlugins() {
    const dirname = path.join(__dirname, '..', 'plugins');
    if (fs.existsSync(dirname)) {
      fs.readdirSync(dirname, { encoding: 'utf8' }).forEach(filename => {
        const pathname = path.join(dirname, filename);
        require(pathname)({ generate, model, config });
      });
    }
  }

  model.collections.post = model.collections.post.sort(
    (a, b) => b.date - a.date,
  );

  processPlugins();

  Object.keys(model.documents).forEach(pathname => {
    const doc = model.documents[pathname];
    const destination = doc.pathname.endsWith('/')
      ? doc.pathname + 'index.html'
      : doc.pathname;
    if (doc.content || doc.source) {
      generate(destination, doc.layout, doc);
    } else {
      copy(
        path.join(config.src, pathname),
        path.join(config.dest, destination),
      );
    }
  });

  console.log(colorize('OK', 'green'));
}

const EventEmitter = require('events');
const buildEvents = new EventEmitter();

function safeBuild() {
  try {
    build();
    buildEvents.emit('success');
  } catch (e) {
    buildEvents.emit('error', e);
    console.error(e);
  }
}

const watching = process.argv.length === 3 && process.argv[2] === '--server';
if (watching) {
  safeBuild();
} else {
  build();
}

if (watching) {
  let to;
  fs.watch(config.src, { recursive: true }, (eventType, filename) => {
    clearTimeout(to);
    to = setTimeout(safeBuild, 50);
  });
  fs.watch(
    path.join(__dirname, '..', 'templates'),
    { recursive: true },
    (eventType, filename) => {
      clearTimeout(to);
      to = setTimeout(safeBuild, 50);
    },
  );
  const { createServer } = require('../lib/server');
  createServer(config, buildEvents);
  console.log('Watching...');
}
